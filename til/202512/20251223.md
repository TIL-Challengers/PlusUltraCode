### DB쓰기와 카프카 발행시점은 언제?? 정합성에 관하여   [OutBox Pattern, @TransactionalEventListener]

기존에는 DB에 특정 entity를 save()를 한 뒤 바로 event를 발행시키는 형태로 코드를 작성했다.
문제가 없이 잘 작동하는 듯 했다.

잠시 고민하고 생각해보니 해당 부분에서는 다음과 같은 문제가 발생한다.

1. DB가 트랜잭션 롤백처리가 된 상황
2. 카프카 발행이 오류가 난 상황

첫번째 문제부터 살펴보자.

### DB가 트랜잭션 롤백처리가 된 상황

데이터의 정합성을 위해서 DB가 롤백이 되면 카프카 처리는 당연히 발행되서는 안된다
다만 관련 방어로직이 없어 현재 코드에서는 바로 발행되는 문제가 생긴다. DB의 commit or rollback에 상관없이 .

해당 문제를 해결하는 방법을 찾아보니 스프링에서 제공하는 @TransactionEventListener를 이용하여 문제를 해결할 수 있었다.

간단하게 설명해보자.

해당 어노테이션은 트랜잭션이 commit된 이후 혹은 이전 등등 특정 시점을 Listener를 할 수 있도록 도와주는 친구다.
예를들어 commit된 이후에만 Listener를 하게 하여 카프카를 발행시키면 첫번째 문제를 해결할 수 있다.

그렇다면 Listener를 하는 기준은 뭘까?? 찾아보니 바로 ApplicationEventPublisher.publish( "도메인 타입" ) 바로 저기 가로안에 들어가는 
도메인 타입을 기준으로 리스터를 작동시킨다. 

entity를 그대로 넘겨도 좋고 dto로 변환하여 넘겨도 좋다. 필자는 dto를 만들어서 listener내부 코드에서 id를 기반으로 entity를 찾은뒤 반환하는 형태로 코드를 작성했다.


### 카프카 발행이 오류가 나나 상황
이 부분은 난처하다.
DB트랜잭션이 정상 처리되었고 카프카 발행이 당연히 되어야 되는 상황에서 안되게 된다면 일라스틱 저장소와 DB저장소간의 정합성 문제가 발생한다.

해당 부분에 대해서 공부한 내용이 바로 OutBox Pattern이다.
DB에 entity를 저장할 때 따로 OutBox 엔티티 또한 저장하는 방식이다.
OutBox의 멤버 변수들은 보통 다음과 같이 정한다.
1. aggreatedId
2. payload
3. createdAt 

실제 저장하고 싶은 entity는 payload변수에 담고 aggreatedId를 통해 해당 OutBox 엔티티의 유일성을 보장해주는 변수를 만든다. 

정리하자면 실제 entity를 저장한 뒤 OutBox Entity또한 저장을 하고 나서
따로 몇초마다 OutBox 테이블에 새로운 레코드가 들어와 있는지 주기적으로 검사하는 클래스 파일을 만든다.

만약 새로운 레코드가 들어 왔으면 그때 발행을 하는 형태로 해당 문제를 타파할 수있다.

이 문제는 아직 해결하지 않아서 다음에 이어서 작성해 보도록 하겠다.
